# SY2221110 田震 Homework_1-1

### 一、

令$f(n) = \begin{cases}1, & n = 1 \\2f(n/2) + n, & n \ge 2\end{cases}\\ $ 则根据定理1， $f(n) = n\log_2n + n$. 

当$n = 1$时，$C(n) = f(n) = 1$;

当$n = 2$时，$C(n) = 2C(1) + 2 - 1 = 2f(1) + 2 - 1 = f(n) - 1$

假设$n =2^1... 2^k$时，均有$C(n) = f(n) - \sum_{i = 0}^{k-1}{2^i}$,

则$n = 2^{k + 1}$时，有：
$$
\begin{aligned}
C(n) &= 2C(n/2) + n - 1\\
&= 2(f(n/2) - \sum_{i = 0}^{k-1}{2^i})+n-1\\
&=2f(n/2) + n - 1 - \sum_{i = 1}^{k}{2^i}\\
&=2f(n/2) + n - \sum_{i = 0}^{k}{2^i}\\
&=f(n) - \sum_{i = 0}^{k}{2^i}
\end{aligned}
$$
由数学归纳法可知，当$n=2^k,$即 $k = \log_2n$时:
$$
\begin{aligned}
C(n) &= f(n) - \sum_{i = 0}^{k-1}{2^i}\\
&=f(n) - \frac{1}{2-1}(2^k - 1)\\
&=f(n) - 2^k + 1\\
&=f(n) - 2^{\log_2n} + 1 \\
&=f(n) - n + 1\\
&=n\log_2n + n - n + 1\\
&=n\log_2n + 1
\end{aligned}
$$
渐进复杂性为$O(nlog_2n)$

### 二、

1. Prim算法是基于图的节点进行遍历，其时间复杂度通常为$O(V^2)$,主要取决于点数，因此比较适用于稠密图。 Kruskal是基于边进行遍历, 其时间复杂度通常为$O(ElogE)$，主要取决于边数，因此比较适用于稀疏图。

   也就是说，不同实例输入下，可以通过比较点和边的数量，来选择具体采用哪种算法计算，从而适用于不同的稠密程度。

2. Prim算法如果采用合适的数据结构（如邻接表）和堆优化，可以使其复杂度达到$O(ElogV)$, 那么其在稀疏图上也可以有比较好的表现，将Prim算法和Kruskal算法集成的意义在一般情况下就不大了。

### 三、

#### 分析正确性：

首先，当$n = 1$时，A中元素直接输出，算法正确，并且当算法执行结束，A中元素恢复成输入的排列，即$[1..n]$；当$n = 2$时，通过简单模拟，也能得知算法结果正确，并且当算法执行结束时，A中元素相较于输入排列，末位提到首位，其他元素相对位置不变，即$[n, 1..n-1]$。

假定$n = 1...k$时算法正确，即能正确生成元素的全排列，并且若n为奇数，当算法执行结束，A中元素恢复成输入的排列；当n为偶数，当算法执行结束，A中元素相较于输入排列，末位提到首位，其他元素相对位置不变。

1）当$n = k + 1$且$n$为奇数($k$为偶数)时，

记数组末位为$end$.

第一次循环，即$i = 1$时，$HeapPermute(n-1)$即$HeapPermute(k)$生成前$k$个元素的全排列，此时$end = k + 1$。在$HeapPermute(n-1)$执行结束后，数组A变为$[k, 1..k-1,k+1]$，接下来，由于$n$为奇数，$A[1]$与$A[n]$交换，即第二次循环前数组A变为$[k+1, 1..k-1, k]$。

第二次循环生成$end = k$的$k!$个全排列，并且在$HeapPermute(n-1)$执行结束后，数组A变为$[k-1, k+ 1, 1..k-2,k]$，接下来，$A[1]$与$A[n]$交换，即第二次循环前数组A变为$[k, k+1, 1..k-2, k-1]$。

以此类推，第$i$次循环，生成$end = n - i + 1$的$k!$种全排列，当$i = n$时，共生成$(k+1)k! = (k+1)!$种不同的全排列，因此$n = k+1$时算法正确。

并且算法执行结束后，数组A恢复成输入的排列，即  $[1..n]$.

2）当$n = k + 1$且$n$为偶数($k$为奇数)时，

记数组末位为$end$，与情况1类似

在第一次循环时，生成$end = k + 1$的$k!$种全排列，并且数组A变为$[k+ 1, 2..k, 1]$.

第二次循环时，生成$end = 1$的$k!$种全排列，并且数组A变为$[k+1,1,3..k,2]$.

以此类推，第$i（i>=2）$次循环，生成$end = i - 1$的$k!$种全排列，并且数组A变为$[k+1,1..i-1,i+1..k,i]$当$i = n = k + 1$时，共生成$k! + k*k = (k+1)!$种不同的全排列，因此$n = k + 1$时算法正确。

并且算法执行结束后，数组A变成$[k+1, 1..k]$即$[n, 1..n-1]$.

综上，由数学归纳法，算法正确。

#### 时间效率

将判断奇偶与交换当作1个时间单元，则由时间随n的递推式：
$$
T(n)=\begin{cases}
1, & n=1\\
n(T(n-1)+1), & n\ge2
\end{cases}
$$
转换为非递归形式，$T(n)=n!+\sum_{i = 1}^{n-1}{\frac{n!}{(n-i)!}}=O(n \times n!)$, 

故时间复杂度为$O(n \times n!)$

### 四、

伪代码：每次减一

```a
MinElementLoc(n)
	if n = 1 then return 0
	x <- MinElementLoc(n - 1)
	if nums[x] > nums[n - 1] 
		then return n - 1; 
		else return x; 
```

记两次if判断为2个时间单元，则$T(n) = \begin{cases}1, &n=1\\T(n-1)+2, & n\ge2\end{cases}$，即$T(n)=2n-1=O(n)$

该问题的蛮力算法比较$n-1$次, 此减治算法与蛮力算法渐进复杂性一一致，均为$O(n)$,但在常数上较大，是由于为判断递归终点多加了一次if判断。

### 五、

非递推公式：
$$
J(n)=2(n-2^{\lfloor\log_2{n}\rfloor})+1, n取正整数
$$
已知递推公式：
$$
J(2k) = 2J(k)-1\\
J(2k+1) = 2J(k)+1\\(k=1,2,3...)\\
$$
下面证明非递推公式满足递推公式：

1. $n = 1$时，$J(1)=1$,满足非递推式

2. 假设对于k，有$J(k)=2(k-2^{\lfloor\log_2{k}\rfloor})+1$成立

   1. 对于$n=2k$,有：
      $$
      \begin{aligned}
      J(2k) &= 2J(k)-1\\
      &= 2\times2(k-2^{\lfloor\log_2{k}\rfloor})+2-1\\
      &=2(2k-2^{\lfloor\log_2{k}\rfloor+1})+1\\
      &=2(2k-2^{\lfloor\log_2{2k}\rfloor})+1
      \end{aligned}
      $$

   2. 对于$n=2k+1$,有：
      $$
      \begin{aligned}
      J(2k+1) &= 2J(k)+1\\
      &= 2\times2(k-2^{\lfloor\log_2{k}\rfloor})+2+1\\
      &=2(2(k+1)-2^{\lfloor\log_2{k}\rfloor+1})+1\\
      &=2(2(k+1)-2^{\lfloor\log_2{2k+1}\rfloor})+1
      \end{aligned}
      $$

​		因此，对于$n=2k$及$n=2k+1$均有非递推式成立

由数学归纳法，该非递推公式满足递推公式。
